# This file belongs in your Config Server's Git Repository
# Path: Monolithic-Config-Server-Repo/monolithic-application-dev.yml

server:
  port: 8086 # Your existing application port

spring:
  application:
    name:  monolithic-application # Added for better identification in logs/metrics
  data:
    mongodb:
      uri: mongodb://localhost:27017/productdb_monolith # Your existing MongoDB connection for products
  datasource:
    url: jdbc:mysql://localhost:3306/monolith_user_book_db?useSSL=false&serverTimezone=UTC # Your existing MySQL connection for users and books
    username: root
    password: root
    driver-class-name: com.mysql.cj.jdbc.Driver
  jpa:
    hibernate:
      ddl-auto: update # Automatically update schema (for development, use 'none' or 'validate' in production)
    show-sql: true # Show SQL queries in logs
    properties:
      hibernate:
        format_sql: true
  liquibase:
    change-log: classpath:db/changelog/db.changelog-master.yaml # Your existing Liquibase config
  mail: # Your existing mail settings
    host: smtp.gmail.com
    port: 587
    username: mahebunnisashaik252@gmail.com # Your actual Gmail email
    password: eovrgpinxtaqlxax # Your actual Gmail app password
    properties:
      mail.smtp.auth: true
      mail.smtp.starttls.enable: true
  thymeleaf: # Your existing Thymeleaf settings
    prefix: classpath:/templates/
    suffix: .html
    cache: false # Disable cache for development

  # Your existing Spring Security JWT properties
  jwt:
    secret: your_very_long_and_complex_jwt_secret_key_here_atleast_256bit_for_HS256 # IMPORTANT: Change this to a strong, random key
    expiration: 3600000 # 1 hour in milliseconds (e.g., for JWT token validity)

# Your existing Eureka Client Configuration
eureka:
  client:
    service-url:
      defaultZone: http://localhost:8761/eureka # URL of your Eureka Server
    register-with-eureka: true # Register this monolithic app with Eureka
    fetch-registry: true
  instance:
    prefer-ip-address: true # Prefer IP address over hostname in Eureka registration

# MERGED Resilience4j Configuration (Detailed settings for productServiceCircuitBreaker, etc.)
resilience4j.circuitbreaker:
  instances:
    productServiceCircuitBreaker: # This name is used in @CircuitBreaker annotation in UserService
      registerHealthIndicator: true # Expose circuit breaker state via /actuator/health
      slidingWindowType: COUNT_BASED # Use count-based window for measuring calls
      slidingWindowSize: 10 # Number of calls in the sliding window
      minimumNumberOfCalls: 5 # Minimum calls before calculating failure rate
      failureRateThreshold: 50 # If 50% or more calls fail, open the circuit (in %)
      waitDurationInOpenState: 5s # How long the circuit stays open before transitioning to HALF_OPEN
      permittedNumberOfCallsInHalfOpenState: 3 # Number of calls allowed in HALF_OPEN to test recovery
      automaticTransitionFromOpenToHalfOpenEnabled: true # Automatically transition to HALF_OPEN after waitDurationInOpenState

resilience4j.retry:
  instances:
    productServiceRetry: # This name is used in @Retry annotation in UserService
      maxAttempts: 3 # Maximum number of retry attempts (1 original + 2 retries)
      waitDuration: 1s # Initial wait duration between retries
      enableExponentialBackoff: true # Increases wait duration exponentially
      exponentialBackoffMultiplier: 2 # Multiplies wait duration by 2 for each retry
      retryExceptions: # Exceptions that should trigger a retry
        - org.springframework.web.client.ResourceAccessException
        - java.util.concurrent.TimeoutException
        - com.example.monolithic.product.exception.ProductServiceCallFailedException # Your custom exception

resilience4j.timelimiter:
  instances:
    productServiceTimeLimiter: # This name is used in @TimeLimiter annotation in UserService
      timeoutDuration: 2s # Maximum allowed execution time for the protected call

# MERGED Micrometer Tracing (Zipkin) and Actuator Endpoints Configuration
management:
  tracing: # Your existing tracing configuration
    enabled: true
    sampling:
      probability: 1.0 # Sample all traces
    propagation:
      type: b3 # B3 propagation format
  zipkin: # Your existing Zipkin configuration
    tracing:
      endpoint: http://localhost:9411/api/v2/spans # Zipkin server endpoint
  endpoints: # Added Actuator endpoint exposure
    web:
      exposure:
        include: "*" # Expose all actuator endpoints (for development, be selective in production)
  endpoint: # Added specific Actuator endpoint details
    health:
      show-details: always # Show full health details
    metrics:
      enabled: true # Enable metrics endpoint
    circuitbreakers:
      enabled: true # Enable circuitbreakers endpoint
    retries:
      enabled: true # Enable retries endpoint
    timelimiters:
      enabled: true # Enable timelimiters endpoint

logging: # Your existing logging configuration
  pattern:
    level: "%5p [${spring.application.name},%X{traceId:-},%X{spanId:-}] %logger{36} : %msg%n"
  level:
    com.example: INFO # Set logging level for your application packages

# Your existing SpringDoc OpenAPI (Swagger UI) Configuration
springdoc:
  swagger-ui:
    path: /swagger-ui.html # Path for Swagger UI
  api-docs:
    path: /v3/api-docs # Path for OpenAPI JSON
  default-produces-media-type: application/json # Default response type
  packages-to-scan: com.example.monolithic # Scan only your application packages for APIs
  show-actuator: true # Show Actuator endpoints in Swagger UI

# Your existing Custom message for this profile
message: "Hello from Config Server for Monolithic Application (DEV Profile)"
